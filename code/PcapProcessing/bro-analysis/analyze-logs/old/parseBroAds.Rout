
R version 2.15.1 (2012-06-22) -- "Roasted Marshmallows"
Copyright (C) 2012 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: i386-apple-darwin9.8.0/i386 (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> baseDir<-"/Users/ashwin/proj-work/meddle/meddle-data/"
> scriptsDir<-"/Users/ashwin/proj-work/meddle/ashwin-meddle/meddle/code/PcapProcessing/bro-analysis/analyze-logs/"
> setwd(scriptsDir);
> broLogsDir<-paste(baseDir, "bro-results/", sep="");
> broAggDir<-paste(baseDir,"bro-aggregate-data/", sep="");
> adBytesFile <- paste(broAggDir, "adBytes.txt", sep="");
> adData <- read.table(paste(broAggDir, "adDomain.txt", sep=""), header=T, sep="\t", fill=TRUE, stringsAsFactors=FALSE, quote=""); # Note FILL causes silent padding
> opar = par();
> # Default parameters for the plots
> par(cex.lab=1.25, cex.axis=1.25, cex.main=1.25, cex.sub=1.25,
+     xaxs="i", yaxs="i",lwd=3);
> 
> isAdAnalyticsDomain <- function (currDomain, adData)  {    
+   strVector<-unlist(strsplit(currDomain, '\\.')); 
+   # We need to support subdomains. For example if admob.com is an ad domain
+   # I assume that *.admob.com is also an ad domain. 
+   retVal <- FALSE;
+   for (i in 2:length(strVector)) {    
+     #print (i);
+     tmpVec <- paste(tail(strVector, i), sep=" ", collapse=".");    
+     #print(tmpVec);
+     if (TRUE == is.element(tmpVec, adData$domain)) {      
+       retVal <- TRUE;      
+       break
+     }
+   }
+   retVal;
+ }
> 
> getAdData <- function(httpData, connData, adData) {
+   nHttpRows <- nrow(httpData);
+   adTable <- data.frame(matrix(nrow=nHttpRows, ncol=7), stringsAsFactors=FALSE, quote="");
+   nAdRow <- 1;
+   for (i in 1:nrow(httpData)) {  
+     entry <- httpData[i, ]; 
+     if ( i %% 500 == 1) {
+       print(i)      
+     }
+     if(TRUE == isAdAnalyticsDomain(entry$host, adData)) {
+       connEntry <- connData[connData$uid == entry$uid,];      
+       #cat(sprintf("%d %d %s %d %d\n", i, sum, connEntry$uid, connEntry$orig_ip_bytes, connEntry$resp_ip_bytes));
+       # Take first entry of the connData as multiple may be found
+       if (nrow(connEntry) >= 1) {
+         # adTable <- rbind(adTable, list(entry$ts, entry$host,  entry$referrer, entry$user_agent, entry$mime_type, as.int64(connEntry$orig_ip_bytes[1]), as.int64(connEntry$resp_ip_bytes[1])));
+         adTable[nAdRow, ] <- list(entry$ts, entry$host,  entry$referrer, entry$user_agent, entry$mime_type, as.double(connEntry$orig_ip_bytes[1]), as.double(connEntry$resp_ip_bytes[1]));
+       } else {
+         # Condition when the conn.log does not have the ip bytes, we use the http bytes 
+         #adTable <-  rbind(adTable, list(entry$ts, entry$host,  entry$referrer, entry$user_agent, entry$mime_type, as.int64(entry$), as.int64(entry$)));    
+         print("Conn Not Found")
+         adTable[nAdRow, ] <- list(entry$ts, entry$host,  entry$referrer, entry$user_agent, entry$mime_type, as.double(entry$request_body_len), as.double(entry$response_body_len));
+       }
+       nAdRow <- nAdRow + 1;
+    }
+   } 
+   adTable <- adTable[1:nAdRow-1, ];
+   totBytes <- sum(connData$orig_ip_bytes) + sum(connData$resp_ip_bytes);
+   list(totBytes, adTable); 
+ }
> #adData <- getAdData();
> #totBytes <- sum(as.numeric(connData$resp_ip_bytes) + as.numeric(connData$resp_ip_bytes));
> 
> parseAdData <- function (adData, userDir) {  
+   print(userDir)
+   fName <- paste(userDir, "/http.log", sep="");
+   httpData <- read.table(fName, header=T, sep="\t", fill=TRUE, stringsAsFactors=FALSE, quote=""); # Note FILL causes silent padding
+   print("Read the httpData")
+   fName <- paste(userDir, "/conn.log", sep="");
+   connData <- read.table(fName, header=T, sep="\t", fill=TRUE, stringsAsFactors=FALSE, quote="");
+   #first make double
+   connData$orig_ip_bytes = as.double(connData$orig_ip_bytes);
+   connData$resp_ip_bytes = as.double(connData$resp_ip_bytes);
+   connData$orig_pkts = as.double(connData$orig_pkts);
+   connData$resp_pkts = as.double(connData$resp_pkts);
+   # massage data if na or invalid entries are present -- this may be due to parsing errors
+   connData$orig_ip_bytes[is.na(connData$orig_ip_bytes)] <-0;
+   connData$resp_ip_bytes[is.na(connData$resp_ip_bytes)] <-0;
+   connData$orig_pkts[is.na(connData$orig_pkts)] <-0;
+   connData$resp_pkts[is.na(connData$resp_pkts)] <-0;
+   print ("Read the connData");
+   adMeta <- getAdData(httpData, connData, adData);    
+ }
> 
> for (userLogsDir in list.dirs(broLogsDir, recursive=FALSE)) { 
+   userName <- basename(userLogsDir)
+   #if ( (userName != "will-droid") && (userName != "will-ipad")) {
+   #if (userName != "parikshan-droid") {
+   #  next;
+   #}
+   userAdData <- parseAdData(adData, userLogsDir);    
+   print("Got AdData; Now Dumping the logs");  
+   adTable <- data.frame(userAdData[2]);
+   adBytes <- (sum(as.double(unlist(adTable$X6)))) + sum(as.double(unlist(adTable$X7))); 
+   print("Dumping the Ad bytes")
+   dataList <- list(userName, as.numeric(userAdData[1]), as.numeric(adBytes));
+   adBytesFile <- paste(broLogsDir,"/userAdBytes.txt", sep="");
+   print(unlist(dataList));
+   print(adBytesFile)
+   cat(unlist(dataList), file=adBytesFile, append=TRUE);
+   cat("\n", file=adBytesFile, append=TRUE);  
+   print("Dumping the ad Table for the user");
+   userAdFile <- paste(broLogsDir, userName, ".adsTable", sep="");  
+   tmpTable <- data.frame(unlist(adTable$X1), unlist(adTable$X2), unlist(adTable$X3), unlist(adTable$X4), unlist(adTable$X5), unlist(adTable$X6), unlist(adTable$X7));
+   write.table(tmpTable, userAdFile, col.names=FALSE, row.names=FALSE);  
+ }                         
[1] "/Users/ashwin/proj-work/meddle/meddle-data/bro-results//05c2c53df8"
[1] "Read the httpData"
[1] "Read the connData"
[1] 1
[1] 501
[1] 1001
[1] 1501
[1] 2001
[1] 2501
[1] 3001
[1] 3501
[1] 4001
[1] 4501
[1] 5001

Execution halted
